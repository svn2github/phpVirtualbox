<!-- 

	Virtual Machine List
	Copyright (C) 2010-2012 Ian Moore (imoore76 at yahoo dot com)
	
	$Id$

 -->
<div id='vboxVMList'>
	<div id='vboxVMListSpinner' style='text-align: center'>
		<img src='images/spinner.gif' alt="" />
	</div>
</div>
<script type='text/javascript'>


/*
 * 
 *
 * Startup for VM List and Toolbar
 *
 */

// Create VM list
var vboxVMList = new vboxVMList('vboxVMList');
vboxVMList.interval = ($('#vboxIndex').data('vboxConfig').listUpdateInterval ? $('#vboxIndex').data('vboxConfig').listUpdateInterval : 5);
// Failsafe
if(isNaN(vboxVMList.interval)) vboxVMList.interval = 5;

// Hold reference in data
$('#vboxIndex').data('vboxChooser', vboxVMList);

// VM List Group context menu
vboxVMList.vmGroupContextMenuItems = [
	$.extend({}, vboxVMGroupActions['newmachine'], {name:'newmachine'}),
	$.extend({}, vboxVMGroupActions['addmachine'], {name:'addmachine'}),
	$.extend({}, vboxVMGroupActions['rename'], {name:'rename',separator:true}),
	$.extend({}, vboxVMGroupActions['ungroup'], {name:'ungroup'}),
	$.extend({}, vboxVMGroupActions['sort'], {name:'sort',separator:true}),
];

// VM List Context menu for each VM
var sChildren = [];
for(var i = 0; i < vboxVMActions.stop_actions.length; i++) {
	sChildren[sChildren.length] = $.extend({},vboxVMActions[vboxVMActions.stop_actions[i]],{'name':vboxVMActions.stop_actions[i],'iconStringDisabled':'_disabled'});
}

/*
 * VM Context menu setup (menu per VM in list)
 */
vboxVMList.vmContextMenuItems = [
	$.extend({},vboxVMActions['settings'],{'name':'settings'}),
	$.extend({},vboxVMActions['clone'],{'name':'clone'}),
	$.extend({},vboxVMActions['remove'],{'name':'remove'}),
	$.extend({},vboxVMActions['group'],{'name':'group'}),
	$.extend({},vboxVMActions['start'],{'name':'start','separator' : true}),
    $.extend({},vboxVMActions['pause'],{'name':'pause'}),
    $.extend({},vboxVMActions['reset'],{'name':'reset'}),
	$.extend({},vboxVMActions['stop'],{'name':'stop','icon':'exit','children':sChildren}),
	$.extend({},vboxVMActions['discard'],{'name':'discard','separator' : true}),
	$.extend({},vboxVMActions['logs'],{'name':'logs'}),
	$.extend({},vboxVMActions['refresh'],{'name':'refresh'})
];

/*
 * VM list context menu setup
 */
vboxVMList.parentContextMenuItems = [
	$.extend({},vboxVMActions['new'],{'name':'new'}),
	$.extend({},vboxVMActions['add'],{'name':'add'}),
	{
		'name':'fileImport',
		'label':trans('Import Appliance...','UIActionPool'),
		'icon':'import',
		'click':function(){vboxWizardImportApplianceInit();},
		'separator': true
	},
	{
		'name':'fileExport',
		'label':trans('Export Appliance...','UIActionPool'),
		'icon':'export',
		'click':function(){vboxWizardExportApplianceInit();}
	},
	$.extend({},vboxVMGroupActions['sort'],{'name':'sort','separator':true,click:function(){
		vboxVMList.sortSelectedGroup(true);
	}})
];


vboxVMList.run();


/*
 * Virtual Machine list object.
 * 
 * This may seem a bit odd: "self.FOO" instead of "this.FOO" used
 * to get around JavaScript limitation. When a method is called
 * as a result of an ajax request returning, "this" refers to the
 * JavaScript window object rather than the originating object.
 * Creating and using a class local "self" variable that refers
 * to the object gets around this limitation.
 */

function vboxVMList(anchorid) {

	var self = this;
	this.vms = null;
	this.anchorid = anchorid;
	this.anchor = $('#'+anchorid);

	this.selectedList = [];
	this.selectedVMs = [];
	
	this.selectionModel = null;
	// Selection model can be
	// singleVM
	// multiVM
	// singleGroup
	// null 
	
	this.lastUpdatedDiv = null;
	this.interval = 5;
	this.changed = false;
	this.versionChecked = false;
	
	this.vmContextMenuItems = [];
	this.vmGroupContextMenuItems = [];
	this.parentContextMenuItems = [];
	this.vmContextMenuObj = null;
	this.vmGroupContextMenuObj = null;
	
	// Group elements with path as the key
	this.vmGroupElements = {};

	this.enforceVMOwnership = $('#vboxIndex').data('vboxConfig').enforceVMOwnership;
	this.tip = trans('<nobr>%1<br></nobr><nobr>%2 since %3</nobr><br><nobr>Session %4</nobr>','UIVMListView');
	
	
	// If there are multiple servers configured, setup menu
	if($('#vboxIndex').data('vboxConfig').servers.length) {

		var servers = $('#vboxIndex').data('vboxConfig').servers;
		var ul = $('<ul />').attr({'id':'vboxServerMenu','style':'display: none','class':'contextMenu'});
		for(var i = 0; i < servers.length; i++) {
			$('<li />').html("<a href='#" + $('<div />').html(servers[i].name).text() + "' style='background-image: url(images/vbox/OSE/VirtualBox_16px.png);'>"+$('<div />').html(servers[i].name).text()+"</a>").appendTo(ul);
		}
		$('#vboxIndex').append(ul);
		
	}
	
	/*
	 * Triggered when selection list has changed
	 */
	self.selectionListChanged = function(selectionList) {
			
		if(!selectionList) selectionList = [];
		
		selectionModel = null;
		
		// Hold unique selected VMs
		var vmListUnique = {};
		for(var i = 0; i < selectionList.length; i++) {
			if(selectionList[i].type == 'group') {
				self.getGroupElement(selectionList[i].groupPath).find('table.vboxVMListVM:not(.ui-draggable-dragging)').each(function(idx,elm){
					var vmid = $(elm).data('vmid');
					if(vmid)
						vmListUnique[vmid] = vmid;			
				});
				switch(selectionModel) {
					case 'singleGroup':
					case 'singleVM':
						selectionModel = 'multiVM';
						break;
					case null:
						selectionModel = 'singleGroup';
				}
			} else {				
				switch(selectionModel) {
					case null:
						selectionModel = 'singleVM';
						break;
					default:
						selectionModel = 'multiVM';
				}

				vmListUnique[selectionList[i].id] = selectionList[i].id;
			}
		}
		
		// Change selection list
		var selectedVMs = [];
		for(var i in vmListUnique) {
			selectedVMs[selectedVMs.length] = i;
		}
		
		self.selectedVMs = selectedVMs;

		// If there is only one unique vm selected,
		// selection model becomes single VM if the
		// current selection model is not singleGroup
		if(self.selectedVMs.length == 1 && selectionModel != 'singleGroup')	
			selectionModel = 'singleVM';

		self.selectionModel = selectionModel;
		
		$('#vboxIndex').trigger('vmSelectionListChanged', [self]);		
		
		// Load any data that needs to be loaded
		for(var i = 0; i < self.selectedVMs.length; i++) {

			var vmid = self.selectedVMs[i];
			
			// Not loaded yet
			if(!self.vms[vmid].phpVbxLoaded) {
				
				$('#vboxIndex').trigger('vmLoading', [self.vms[vmid], self]);
				
				var localVMid = vmid;
				
				// Send ajax off to get data
				vboxAjaxRequest('machineGetDetails', {'vm':localVMid}, function(data) {
					self.vmLoaded(data);
				});	
			};
			
		};
		

	};
	
	/*
	 * Return a single vm if it is selected
	 */
	self.getSingleSelected = function() {
		if(self.selectedVMs.length == 1) {
			return self.vms[self.selectedVMs[0]];
		}
		return null;
	 };
	
	/*
	 * Triggered after a VM is loaded
	 */
	self.vmLoaded = function(data) {
		var exData = self.vms[data.id];
		$.extend(exData,data,{phpVbxLoaded:true});
		self.vms[data.id] = exData;
		$('#vboxIndex').trigger('vmLoaded', [self.vms[data.id], self]);
	};
 
	/*
	 * Update list of VMs from data received
	 * from ajax query
	 */
	self.updateList = function(d) {

		// We were stopped before the request returned data
		if(!self._running) return;
		
		
		if(!d || !d.vmlist) {
			
			vboxAlert(trans('There was an error obtaining the list of registered virtual machines from VirtualBox. Make sure vboxwebsrv is running and that the settings in config.php are correct.<p>The list of virtual machines will not begin auto-refreshing again until this page is reloaded.</p>','phpVirtualBox'));
			
			self.stop();
			self.anchor.children().remove();
			return;
		}

		var currTime = new Date();
		self.time = currTime.getTime();

		/* Check Key
			If we've changed hosts before the last ajax call to get a list of VMs
			returns, we'd have a list of VMs from the previously selected VirtualBox
			host.
		*/
		if(d.server_key != $('#vboxIndex').data('vboxConfig').key) return;
		
		/*
		 * Don't update if paused.. 
		 * happens while dragging and creating group definitions
		 */
		if(self.paused) return;
		
		currVMList = d.vmlist;
		

		var firstRun = false;
		
		// First time run?
		if(self.vms === null) {
			
			// Remove spinner
			self.anchor.children().remove();
			
			// reset selfvms and add host
			self.vms = {
				host : {
					'id':'host',
					'state':'Hosting',
					'owner':'',
					'name':$('#vboxIndex').data('vboxConfig').name,
					'OSTypeId':'VirtualBox_Host',
					lastUpdated:self.time
				}
			};
			
			// Render host
			self.anchor.append(self.vmHTML(self.vms['host']));
			
			// Render root group
			self.anchor.append(self.groupHTML("/"));
			
			firstRun = true;
			
		}

		// Add host
		currVMList[currVMList.length] = {
			'id':'host',
			'state':'Hosting',
			'owner':'',
			'name':$('#vboxIndex').data('vboxConfig').name,
			'OSTypeId':'VirtualBox_Host',
			lastUpdated:self.time
		};
		
		
		// Enforce VM ownership
        if(self.enforceVMOwnership && !$('#vboxIndex').data('vboxSession').admin) {
        	currVMList = jQuery.grep(currVMList,function(vm,i){
        		return (vm.owner == $('#vboxIndex').data('vboxSession').user);
        	});
		}
	
		// Each item in list
		for(var i = 0; i < currVMList.length; i++) {	
			
			// Update
			self.updateVM(currVMList[i]);

			self.vms[currVMList[i].id].lastUpdated = self.time;
			
		}

		// Check for any vms that should be removed
		for(var id in self.vms) {
			if(self.vms[id].lastUpdated != self.time) {
				self.machineRemove(id);
			}
		}
		
		// Update "Last Updated" ?
		if(self.lastUpdatedDiv) {
			var hours = currTime.getHours();
			var minutes = currTime.getMinutes();
			var secs = currTime.getSeconds();
			if (minutes < 10) minutes = "0" + minutes;
			if (secs < 10) secs = "0" + secs;
			
			$(self.lastUpdatedDiv).html(hours+':'+minutes+':'+secs);
		}
		
		// compose / save group definitions if this
		// is the first run
		if(firstRun) self.composeGroupDef();
		
	};
	
	/*
	 * Get group element by path
	 */
	self.getGroupElement = function(gpath) {
		
		var gnames = gpath.split('/');
		var groot = self.anchor.children('div.vboxVMListGroup');
		for(var i = 1; i < gnames.length; i++) {
			
			if(!gnames[i]) continue;
			
			var group = groot.children('div.vboxVMListGroup').children('div.vboxVMListGroupHeader[title="'+gnames[i]+'"]').parent();
			
			
			// If it does not exist, create it
			if(!group[0]) {
				
				var gpath = '/';
				for(var a = 1; a <= i; a++) {
					gpath = gpath + '/' + gnames[a];
				}
				gpath = gpath.replace('//','/');
				
				self.groupHTML(gpath).insertBefore(groot.children('div.vboxVMListGroupVMs'));
				
				self.sortGroup(groot);
				
				groot = groot.children('div.vboxVMListGroup').children('div.vboxVMListGroupHeader[title="'+gnames[i]+'"]').parent();
				
			} else {
				groot = group;
			}
			
		}
		return groot;
	};

	/*
	 *
	 * Update VM data
	 *
	 */
	self.updateVM = function(vmUpdate,index) {

		var changed = false;
		var newVM = false;
		var changedProps = ['currentSnapshotName','state','sessionState','OSTypeId','name','customIcon'];
		
		if(!self.vms[vmUpdate.id]) {
			changed = true;
			newVM = true;
		} else {
			for(var i = 0; i < changedProps.length; i++) {
				if(String(self.vms[vmUpdate.id][changedProps[i]]) != String(vmUpdate[changedProps[i]])) {
					changed = true;
					break;
				}
			}
		}		

		// If a watched attribute has changed,
		// Re-load data if VM is selected
		if(changed) {

			// New VM.. add it to groups..
			if(newVM && vmUpdate.id != 'host') {
				
				if(!vmUpdate.groups || vmUpdate.groups.length == 0)
					vmUpdate.groups = ['/'];
				
				for(var i = 0; i < vmUpdate.groups.length; i++) {
					var gElm = $(self.getGroupElement(vmUpdate.groups[i]));
					self.vmHTML(vmUpdate).appendTo(
						gElm.children('div.vboxVMListGroupVMs')
					);
					self.sortGroup(gElm);
				}
				
			// Existing VM. Replace existing elements
			} else {
				
				$('#'+self.anchorid).find('table.vboxVMListItem-'+self.anchorid+'-'+vmUpdate.id).each(function(i,elm){
					
					var newHTML = self.vmHTML(vmUpdate);
					if($(elm).hasClass('vboxListItemSelected')) {
						$(newHTML).addClass('vboxListItemSelected').removeClass('vboxHover');
					}
					$(elm).replaceWith(newHTML);
				});
			}
			self.vms[vmUpdate.id] = vmUpdate;

			// Only trigger this if it is not a new VM
			if(!newVM) {
				$('#vboxIndex').trigger('vmChanged', [vmUpdate.id]);
			}
		}
		

		return newVM;
	};
	
	/*
	 * VM data changed
	 */
	self.vmChanged = function(e, vmid) {
		
		// Is it a selected VM?
		if(vmid && jQuery.inArray(vmid, self.selectedVMs) > -1) {
			
			$('#vboxIndex').trigger('vmLoading', [self.vms[vmid], self]);
			
			
			// Send ajax off to get data
			vboxAjaxRequest('machineGetDetails', {'vm':vmid}, function(data) {
				self.vmLoaded(data);
			});	

		// Else make sure we reload data the next time it is selected
		} else if (vmid && self.vms[vmid]) {
			self.vms[vmid].phpVbxLoaded = false;
		}
	};


	/*
	 * Generate HTML from VM definition
	 */
	self.vmHTML = function (vmn) {
		
		var tbl = $('<table />').attr({'class':'vboxVMListItem-'+self.anchorid+'-'+vmn.id + " vboxVMListVM"}).bind('click',self.selectItem).hover(function(){
			if(!$(this).hasClass('vboxListItemSelected'))
				$(this).addClass('vboxHover');
			},function(){$(this).removeClass('vboxHover');}).data('vmid',vmn.id);
		
		
		// Drag-and-drop functionality
		/////////////////////////////////
		if(vmn.id != 'host') {
			
			$(tbl).draggable({'cursorAt':{left: -10, top: -10},'helper':function(){
				return $(this).clone().css({'width':($(this).width()+2)+'px','display':'inline','background':'#fff','border-color':'#69f'}).removeClass('vboxHover');
				
			// drag start
			},'start':function(e) {
								
				self.paused = true;
				
				$(self.anchor).disableSelection();
				self._dragging = vmn.id;
				$(self.anchor).find('table.vboxHover').removeClass('vboxHover');
				
			// drag stop
			},'stop':function(e) {
				self.vmDropped(e, $(this));
				self.paused = false;
			}});
		}

		// Functionality to drop above / below VM
		/////////////////////////////////////////////
		var td = $('<td />').attr({'colspan':'2'}).addClass('vboxVMListDropTarget vboxDropTargetTop');
		if(vmn.id != 'host') {
			td.hover(function(){
				if(self._dragging && self._dragging != vmn.id)
					$(this).addClass('vboxVMListDropTargetHover');
			},function(){
				$(this).removeClass('vboxVMListDropTargetHover');
			}
			);
		}
		$('<tr />').append(td).appendTo(tbl);

		
		
		// VM OS type icon
		var tr = $('<tr />');
		if($('#vboxIndex').data('vboxConfig').enableCustomIcons && vmn.customIcon) {
			$('<td />').attr({'rowspan':'2'}).html("<img src='" + vmn.customIcon + "' class='vboxVMIcon' />").appendTo(tr);
		} else {
			$('<td />').attr({'rowspan':'2'}).html("<img src='images/vbox/" + vboxGuestOSTypeIcon(vmn.OSTypeId) + "' class='vboxVMIcon" + (vmn.id == 'host' ? " vboxHostIcon" : "") + "' />").appendTo(tr);
		}
		
		
		// VM Name
		var td = $('<td />').attr({'class':'vboxVMTitle'});
		
		// Host will have HTML in name
		if(vmn.id == 'host') {
			
			// Check for multiple server config
			if($('#vboxIndex').data('vboxConfig').servers.length) {
				var span = $('<span />').attr({'class':'vboxServerLink'}).text('('+$('#vboxIndex').data('vboxConfig').name+')').contextMenu({
						menu: 'vboxServerMenu',
						button: 0,
						mode: 'menu'
					},
					function(a) {
						if(a == $('#vboxIndex').data('vboxConfig').name) return;						
						vboxSetCookie("vboxServer",a);
						$('#vboxIndex').trigger('hostChange',[a]);
					}
				);
				$(td).html('<span class="vboxVMName">VirtualBox</span> ').append(span);
			} else {				
				$(td).html('<span class="vboxVMName">VirtualBox</span> ('+vmn.name+')');
			}
			
		// Not rendering host
		} else {
			
			$(td).append('<span class="vboxVMName">'+$('<span />').text(vmn.name).html()+'</span>'+ (vmn.currentSnapshotName ? ' (' + $('<span />').text(vmn.currentSnapshotName).html() + ')' : ''));
			
			var sdate = new Date(vmn.lastStateChange * 1000);

			// Table gets tool tips
			tip = self.tip.replace('%1',('<b>'+$('<span />').text(vmn.name).html()+'</b>'+(vmn.currentSnapshotName ? ' (' + $('<span />').text(vmn.currentSnapshotName).html() + ')' : ''))).replace('%2',trans(vboxVMState(vmn.state),'VBoxGlobal')).replace('%3',sdate.toLocaleString()).replace('%4',trans(vmn.sessionState,'VBoxGlobal'));
			$(tbl).tipped({'source':tip,'position':'mouse','delay':2000});
		}
		
		$(tr).append(td).appendTo(tbl);
		
		// VM state row
		var tr = $('<tr />');
		var td = $('<td />').attr({'class':(vmn.id != 'host' && vmn.sessionState != 'Unlocked' ? 'vboxVMSessionOpen' : '')}).html("<img src='images/vbox/" + vboxMachineStateIcon(vmn.state) +"' /> <span class='vboxVMState'>" + trans(vboxVMState(vmn.state),'VBoxGlobal') + '</span>');

		// Add VirtualBox version if hosting
		if(vmn.id == 'host') {
			
			$(td).append(' - ' + $('#vboxIndex').data('vboxConfig').version.string);
			
			// Check for version mismatches?
			if(!self.versionChecked) {
				self.versionChecked = true;
				var vStr = $('#vboxIndex').data('vboxConfig').phpvboxver.substring(0,$('#vboxIndex').data('vboxConfig').phpvboxver.indexOf('-'));
				var vers = $('#vboxIndex').data('vboxConfig').version.string.replace('_OSE','').split('.');
				if(vers[0]+'.'+vers[1] != vStr) {
					vboxAlert('This version of phpVirtualBox ('+$('#vboxIndex').data('vboxConfig').phpvboxver+') is incompatible with VirtualBox ' + $('#vboxIndex').data('vboxConfig').version.string + ". You probably need to <a href='http://code.google.com/p/phpvirtualbox/downloads/list?q=phpvirtualbox-"+vers[0]+'.'+vers[1]+"' target=_blank>download the latest phpVirtualBox " + vers[0]+'.'+vers[1] + "-x</a>.<p>See the Versioning section <a href='http://code.google.com/p/phpvirtualbox/downloads/detail?name=README.txt' target=_blank>here</a> for more information</p>",{'width':'auto'});
				}
			}			
		}
		
		$(tr).append(td).appendTo(tbl);

		// Droppable targets
		var td = $('<td />').attr({'colspan':'2'}).addClass('vboxVMListDropTarget vboxDropTargetBottom');
		if(vmn.id != 'host') {
			td.hover(function(){
				if(self._dragging && self._dragging != vmn.id)
					$(this).addClass('vboxVMListDropTargetHover');
				},function(){
					$(this).removeClass('vboxVMListDropTargetHover');
				}
			);
		}
		$('<tr />').append(td).appendTo(tbl);
		
		
		// Context menus?		
		$(tbl).contextMenu({
			menu: self.vmContextMenuObj.menuId(),
			menusetup : function(el) {
				if(!$(el).hasClass('vboxListItemSelected')) $(el).trigger('click');
			}
		},function(act,el,pos,d,e){
			self.vmContextMenuObj.menuClickCallback(act, el);
		});
		
		// Open settings on dblclick
		$(tbl).dblclick(function(){
			if(self.vmContextMenuObj.menuItems['settings'].enabled(self))
				self.vmContextMenuObj.menuItems['settings'].click();
		});
		
		return tbl;
		
	};

	/*
	 * VM Group Dropped
	 */
	self.vmGroupDropped = function(e, droppedGroup) {
		
		$(self.anchor).enableSelection();
		
		var vmGroupPath = self._draggingGroup;
		
		self._draggingGroup = false;
		
		$(droppedGroup).removeClass('vboxHover');
		
		// Cannot drag a group that contains a VM without
		// an unlocked session state if it will modify VM
		// Groups
		var sessionLocked = false;
		if($(droppedGroup).find('td.vboxVMSessionOpen')[0])
			sessionLocked=true;

		
		// Check for above/below group first
		var dropTarget = self.anchor.find('div.vboxVMListDropTargetHover').first();
		if(dropTarget[0]) {

			// Make sure that this wasn't dropped onto a sub-group or itself
			if(
					vmGroupPath == dropTarget.closest('div.vboxVMListGroup').data('vmGroupPath')
							||
					dropTarget.closest('div.vboxVMListGroup').data('vmGroupPath').indexOf(vmGroupPath + '/') == 0 
			) {
				return;
			}


			// If we are not still in the same group, check for name conflict							
			var currParentGroupPath = $(droppedGroup).closest('div.vboxVMListGroup').parent().closest('div.vboxVMListGroup').data('vmGroupPath');
			
			if(dropTarget.closest('div.vboxVMListGroup').parent().closest('div.vboxVMListGroup').data('vmGroupPath') != currParentGroupPath) {

				// Do not allow to be dragged into another group
				// if there is a Vm with a locked session in this one
				if(sessionLocked) return;
				
				// Make sure there are no conflicts
				var groupName = $(droppedGroup).children('div.vboxVMListGroupHeader').attr('title');
				var newGroupName = groupName;
				

				var i = 2;
				while(self.groupNameConflicts(dropTarget.closest('div.vboxVMListGroup').parent(), newGroupName)) {
					newGroupName = groupName + ' (' + (i++) + ')';				
				}
				
				$(droppedGroup).children('div.vboxVMListGroupHeader').attr({'title':newGroupName})
					.children('span.vboxVMListGroupName').text(newGroupName);
			
			}

			// Insert before or insert after?
			if(dropTarget.hasClass('vboxDropTargetTop')) {
				$(droppedGroup).detach().insertBefore(dropTarget.closest('div.vboxVMListGroup'));
			} else {
				$(droppedGroup).detach().insertAfter(dropTarget.closest('div.vboxVMListGroup'));
			}

			
		// Dropped onto a group or main VM list
		} else {
			
			// Will not do this if this group contains
			// a VM with a locked session
			if(sessionLocked) return;
			
			var dropTarget = self.anchor.find('div.vboxHover').first();
			
			
			// Dropped onto a group
			if(dropTarget[0] && dropTarget.parent().hasClass('vboxVMListGroup')) {
				
				dropTarget = dropTarget.parent();
				
				// Make sure that this wasn't dropped onto a sub-group or itself
				if(
						vmGroupPath == dropTarget.data('vmGroupPath')
								||
						dropTarget.closest('div.vboxVMListGroup').data('vmGroupPath').indexOf(vmGroupPath + '/') == 0 
				) {
					return;
				}

			// Dropped onto main vm list
			} else if($(self.anchor).hasClass('vboxVMListDropTargetHoverRoot')) {
				
				dropTarget = self.anchor.children('div.vboxVMListGroup');
				
			} else {
				return;
			}
			
			// Make sure there are no conflicts
			var newElm = $(droppedGroup).detach();
			var groupName = $(droppedGroup).children('div.vboxVMListGroupHeader').attr('title');
			var newGroupName = groupName;
			
			var i = 2;
			while(self.groupNameConflicts(dropTarget, newGroupName, $(newElm).data('vmGroupPath'))) {
				newGroupName = groupName + ' (' + (i++) + ')';				
			}
			
			$(newElm)
				.children('div.vboxVMListGroupHeader').attr({'title':newGroupName})
				.children('span.vboxVMListGroupName').text(newGroupName);
			$(newElm).insertBefore(dropTarget.children('div.vboxVMListGroupVMs'));
			
		}

		self.composeGroupDef();
		
		self.selectionListChanged(self.selectedList);
		
	};
	
	/*
	 * VM dropped
	 */
	self.vmDropped = function (e, droppedVM){
		
		$(self.anchor).enableSelection();
		self._dragging = null;
		
		// Cannot drag if this VM's session is not open
		var thisSessionLocked = false;
		if(self.vms[$(droppedVM).data('vmid')].sessionState != 'Unlocked')
			thisSessionLocked = true;

		
		// Where was this dropped?
		var dropTarget = $('#'+self.anchorid).find('td.vboxVMListDropTargetHover');
		
		// Dropped above / below a VM
		if(dropTarget[0]) {
			
			// Dropped from another group into this one,
			// but this group already has this VM
			if((dropTarget.closest('table').closest('div.vboxVMListGroup').data('vmGroupPath') != $(droppedVM).closest('div.vboxVMListGroup').data('vmGroupPath')) 
					&& dropTarget.closest('table').siblings('table.vboxVMListItem-'+self.anchorid+'-'+$(droppedVM).data('vmid'))[0]) {
					return true;
			}
			
			// If session of this VM is locked, don't allow it to be
			// dragged out of current group
			if(thisSessionLocked && ($(droppedVM).closest('div.vboxVMListGroup').data('vmGroupPath') != dropTarget.closest('div.vboxVMListGroup').data('vmGroupPath'))) {
				return
			}
			
			// Get VM from target's parent table
			if(dropTarget.hasClass('vboxDropTargetTop')) {
				if(!e.ctrlKey && !e.metaKey) $(droppedVM).detach().insertBefore($(dropTarget).closest('table'));
				else self.vmHTML(self.vms[$(droppedVM).data('vmid')]).insertBefore($(dropTarget).closest('table'));
			} else {
				if(!e.ctrlKey && !e.metaKey) $(droppedVM).detach().insertAfter($(dropTarget).closest('table'));
				else self.vmHTML(self.vms[$(droppedVM).data('vmid')]).insertAfter($(dropTarget).closest('table'));
			}
		
		// Not dropped above / below vm
		} else {
			
			// Don't allow this if sessoin is locked
			if(thisSessionLocked) return;
			
			// Dropped ON a vm?
			dropTarget = $('#'+self.anchorid).find('table.vboxHover').first();
			if($(dropTarget).data('vmid')) {
			
				// Create a group?
				dropTarget = $('#'+self.anchorid).find('table.vboxHover').first();
				
				// Nothing to do. Not dropped on valid target
				if(!dropTarget[0] || ($(dropTarget).data('vmid') == $(droppedVM).data('vmid'))) return true;
									
				// Dont' allow this if target VM's session is locked
				if($(dropTarget).find('td.vboxVMSessionOpen')[0])
					return;
				
				// Where to drop this..
				var p = dropTarget.closest('div.vboxVMListGroup').children('div.vboxVMListGroupVMs');
				// assume root?
				if(!p[0]) p = self.anchor.children('div.vboxVMListGroupVMs');

				// Determine group name
				var gname = trans('New group','UIGChooserModel');
				var tgname = gname;

				var i = 2;
				while(self.groupNameConflicts($(p).parent(), tgname)) {
					tgname = gname + ' ' + (i++);
				}

			
				// New position is below target
				var ghtml = self.groupHTML(String(dropTarget.closest('div.vboxVMListGroup').data('vmGroupPath')+'/'+tgname).replace('//','/'));
				
				if(!e.ctrlKey && !e.metaKey) {
					ghtml.children('div.vboxVMListGroupVMs').append($(droppedVM).detach());
				} else {
					ghtml.children('div.vboxVMListGroupVMs').append(self.vmHTML(self.vms[$(droppedVM).data('vmid')]));
				}
				ghtml.children('div.vboxVMListGroupVMs').append(dropTarget.detach());
				
				ghtml.insertBefore(p);
				
			// Dropped in the main VM list or group header?
			} else {
				
				dropTarget = $(self.anchor).find('div.vboxHover').first();
				if(dropTarget[0] && dropTarget.hasClass('vboxVMListGroupHeader')) {
					
					// Group already has this VM?
					if(dropTarget.siblings('div.vboxVMListGroupVMs').children('table.vboxVMListItem-'+self.anchorid+'-'+$(droppedVM).data('vmid'))[0]) {
						return;
					}
					
					if(!e.ctrlKey && !e.metaKey)
						$(droppedVM).detach().appendTo(dropTarget.siblings('div.vboxVMListGroupVMs').first());
					else
						self.vmHTML(self.vms[$(droppedVM).data('vmid')]).appendTo(dropTarget.siblings('div.vboxVMListGroupVMs').first());
				
				// Main VM list
				} else if($(self.anchor).hasClass('vboxVMListDropTargetHoverRoot')) {
				
				
					// Already in this list?
					if(self.anchor.children('div.vboxVMListGroup').children('div.vboxVMListGroupVMs').children('table.vboxVMListItem-'+self.anchorid+'-'+$(droppedVM).data('vmid'))[0]) {
						return true;
					}
					
					if(!e.ctrlKey && !e.metaKey) {
						$(droppedVM).detach().appendTo(self.anchor.children('div.vboxVMListGroup').children('div.vboxVMListGroupVMs').first());
					} else {
						self.vmHTML(self.vms[$(droppedVM).data('vmid')]).appendTo(self.anchor.children('div.vboxVMListGroup').children('div.vboxVMListGroupVMs').first());
					}

				}
			}
			
		}

		self.composeGroupDef();
		
		self.selectionListChanged(self.selectedList);
		
	};
	
	/*
	 * Machine removed from list
	 */
	self.machineRemove = function(id) {
		
		var changed = false;
		
		var selectedList = self.selectedList.filter(function(v){
			return (v.type == 'group' || (v.id != id));
		});
		
		if (self.selectedList.length != selectedList.length)
			changed = true;
		
		self.selectedList = selectedList;
		
		if(changed)
			$('#vboxIndex').trigger('vmSelectionListChanged', [self]);
		
		$('#'+self.anchorid +' table.vboxVMListItem-'+self.anchorid+'-'+id).remove();
		
		$('#vboxIndex').trigger('vmRemoved', [id, self]);
		
		delete self.vms[id];
	};

	/*
	 * groupSelectedItems
	 */
	self.groupSelectedItems = function() {
		
		self.paused = true;
		
		// Determine group name
		var gname = trans('New group','UIGChooserModel');
		var tgname = gname;

		var i = 2;
		while(self.groupNameConflicts(self.anchor.children('div.vboxVMListGroup'), tgname)) {
			tgname = gname + ' ' + (i++);
		}
		
		var gHTML = self.groupHTML('/'+tgname);

		// Append group and vm elements
		self.anchor.find('div.vboxGroupSelected').detach().insertAfter(gHTML.children('div.vboxVMListGroupHeader'));
		self.anchor.find('table.vboxListItemSelected').detach().appendTo(gHTML.children('div.vboxVMListGroupVMs'));

		gHTML.insertBefore(self.anchor.children('div.vboxVMListGroup').children('div.vboxVMListGroupVMs'));
		
		self.composeGroupDef();
		
		self.paused = false;
	};
	
	/*
	 * Compose group data from GUI
	 */
	self.composeGroupDef = function() {
		
		var allGroups = [];
		var groupsResolved = false;
		
		// Keep looping through group definitions until
		// there are no groups removed
		while(!groupsResolved) {
			
			allGroups = [];
			groupsResolved = true;
			
			self.anchor.find('div.vboxVMListGroup').each(function(idx,elm) {
				
				// Compose group path
				var myPath = $(elm).children('div.vboxVMListGroupHeader').attr('title');
				if(!myPath) myPath = '/';
				$(elm).parents('div.vboxVMListGroup:not(.ui-draggable-dragging)').each(function(idx2,elm2){
					var pName = $(elm2).children('div.vboxVMListGroupHeader').attr('title');
					if(!pName) pName = '/';
					myPath = String(pName + '/' + myPath).replace('//','/');
				});
								
				// Groups
				var gList = [];
				$(elm).children('div.vboxVMListGroup:not(.ui-draggable-dragging)').each(function(idx2,elm2){
					
					// If this group is selected, we'll have to update its path
					// in the selection list
					var selected = $(elm2).hasClass('vboxGroupSelected');
					var oldPath = null;
					if(selected) {
						oldPath = $(elm2).data('vmGroupPath');
					}
					var newPath = String(myPath + '/' + $(elm2).children('div.vboxVMListGroupHeader').attr('title')).replace('//','/');
					
					gList[gList.length] = $(elm2).children('div.vboxVMListGroupHeader').attr('title');
					
					// set / correct group path data
					$(elm2).data('vmGroupPath', newPath);
					
					// Change selected group's path?
					if(selected && (oldPath != newPath)) {
						for(var i = 0; i < self.selectedList.length; i++) {
							if(self.selectedList[i].type == 'group' && self.selectedList[i].groupPath == oldPath) {
								self.selectedList[i].groupPath = String(myPath + '/' + $(elm2).children('div.vboxVMListGroupHeader').attr('title')).replace('//','/');
								break;
							}
						}
					}
					
				});
				
				// VMs
				var vmList = [];
				$(elm).children('div.vboxVMListGroupVMs').children('table.vboxVMListVM:not(.ui-draggable-dragging)').each(function(idx3,elm3){
					vmList[vmList.length] = $(elm3).data('vmid');
				});
				
				// Skip and remove if there are no VMs or subgroups
				if(gList.length + vmList.length == 0) {
					$(elm).empty().remove();
					groupsResolved = false;
					return false;
				}
				
				// append to all groups list
				allGroups[allGroups.length] = {
					path: $(elm).data('vmGroupPath'),
					subgroups: gList,
					machines: vmList
				};
				
				// Update counts span
				$(elm).children('div.vboxVMListGroupHeader').children('span.vboxVMListGroupInfo')
					.children('span.vboxVMListGroupCounts').html(
						(gList.length ? ('<img src="images/vbox/nw_16px.png" />'+gList.length) : '') +
						(vmList.length ? (' <img src="images/vbox/fullscreen_16px.png" />'+vmList.length) : '')
				);
			});
			
		}
		
		// Save GUI group definition
		$('#vboxIndex').data('vboxVMGroups', allGroups);
		vboxAjaxRequest('vboxGroupDefinitionsSet',{'groupDefinitions':allGroups},function(){});		

		// Machine groups and trigger change
		for(var i in self.vms) {
			
			if(typeof i != 'string' || i == 'host') continue;
			
			vboxAjaxRequest('machineSaveGroups',{'vm':i,'groups':self.getGroupsForVM(i)},function(res){
					if(res.saved) {
						$('#vboxIndex').trigger('vmChanged',[res.vm]);
					}
			});
			
		};
		
		return allGroups;
		
	};
	
	/*
	 * Return a list of groups that VM is a member of
	 */ 
	self.getGroupsForVM = function(vmid) {
		var gPathList = [];
		self.anchor.find('div.vboxVMListGroup:not(.ui-draggable-dragging)').find('table.vboxVMListItem-'+self.anchorid+'-'+vmid+':not(.ui-draggable-dragging)').each(function(idx,elm){
			gPathList[gPathList.length] = $(elm).closest('div.vboxVMListGroup').data('vmGroupPath');
		});
		return gPathList;
	};
	
	/*
	 * Determine whether or not a group name conflicts
	 * with another group in parent
	 */
	self.groupNameConflicts = function(parentGroup, name, ignoreGroupAtPath) {
		var found = false;
		parentGroup.children('div.vboxVMListGroup:not(.ui-draggable-dragging)').children('div.vboxVMListGroupHeader[title="'+name+'"]').parent().each(function(i,elm){
			
			if(ignoreGroupAtPath && (ignoreGroupAtPath == $(elm).data('vmGroupPath')))
				return true;
			
			found=true;
			return false;
		});
		return found;
	};
	
	/*
	 * Ungroup selected group
	 */
	self.unGroupSelectedGroup = function() {

		self.paused = true;
		
		var target = $(self.getSelectedGroupElements()[0]).siblings('div.vboxVMListGroupVMs');
		
		// Groups
		// - ignore group at path we are currently ungrouping
		var ignoreGroup = $(self.getSelectedGroupElements()[0]).data('vmGroupPath');
		$(self.getSelectedGroupElements()[0]).children('div.vboxVMListGroup').each(function(i,elm) {
			
			// Make sure there are no conflicts
			var newElm = $(elm).detach();
			var groupName = $(elm).children('div.vboxVMListGroupHeader').attr('title');
			var newGroupName = groupName;

			var i = 2;
			while(self.groupNameConflicts($(target).parent(), newGroupName, ignoreGroup)) {
				newGroupName = groupName + ' (' + (i++) + ')';				
			}
			
			$(newElm).children('div.vboxVMListGroupHeader').attr({'title':newGroupName}).children('span.vboxVMListGroupName').text(newGroupName);
			
			$(newElm).insertBefore(target);
			
		});
		
		// VMs
		$(self.getSelectedGroupElements()[0]).children('div.vboxVMListGroupVMs').children().each(function(i,elm){
			$(elm).detach();
			if(!target.children('table.vboxVMListItem-'+self.anchorid+'-'+$(elm).data('vmid'))[0])
				target.append(elm);
		});
		
		
		self.composeGroupDef();
		
		self.selectionListChanged();
		
		self.paused = false;

	};
	
	/*
	 *
	 */
	self.sortGroup = function(gElm) {
		
		// Find group orders
		var gPath = $(gElm).data('vmGroupPath');
		var groupList = $('#vboxIndex').data('vboxVMGroups');
		
		var groupOrder = [];
		var vmOrder = [];
		
		for(var i = 0; i < groupList.length; i++) {
			if(groupList[i].path == gPath) {
				groupOrder = groupList[i].subgroups;
				vmOrder = groupList[i].machines;
				break;
			}
		}
		
		// sort groups
		var groups = $(gElm).children('div.vboxVMListGroup').get();
		groups.sort(function(a,b){
			
			var Pos1 = jQuery.inArray($(a).children('div.vboxVMListGroupHeader').attr('title'), groupOrder);
			var Pos2 = jQuery.inArray($(b).children('div.vboxVMListGroupHeader').attr('title'), groupOrder);
			
			return (Pos1 > Pos2 ? 1 : (Pos2 > Pos1 ? -1 : 0));
			
		});
		$.each(groups, function(idx,itm) {
			$(itm).insertAfter($(gElm).children('div.vboxVMListGroupHeader'));
		});
		
		// sort VMs
		var vms = $(gElm).children('div.vboxVMListGroupVMs').children('table.vboxVMListVM').get();
		vms.sort(function(a,b) {
			var Pos1 = jQuery.inArray($(a).data('vmid'), vmOrder);
			var Pos2 = jQuery.inArray($(b).data('vmid'), vmOrder);
			
			return (Pos1 > Pos2 ? 1 : (Pos2 > Pos1 ? -1 : 0));
		});
		$.each(vms, function(idx,itm) {
			$(gElm).children('div.vboxVMListGroupVMs').append(itm);
		});
		
		
	};
	
	/*
	 * Sort selected group by item names
	 */
	self.sortSelectedGroup = function(rootElm) {

		var el = $(self.getSelectedGroupElements()[0]);
		
		if(rootElm || !el) {
			el = self.anchor.children('div.vboxVMListGroup');
		}
		
		// sort groups
		var groups = $(el).children('div.vboxVMListGroup').get();
		groups.sort(function(a,b){
			return $(b).children('div.vboxVMListGroupHeader').attr('title').localeCompare($(a).children('div.vboxVMListGroupHeader').attr('title'));
		});
		$.each(groups, function(idx,itm) {
			$(itm).insertAfter($(el).children('div.vboxVMListGroupHeader'));
		});
		
		// sort VMs
		var vms = $(el).children('div.vboxVMListGroupVMs').children('table.vboxVMListVM').get();
		vms.sort(function(a,b) {
			return $(a).find('td.vboxVMTitle').text().localeCompare($(b).find('td.vboxVMTitle').text());
		});
		$.each(vms, function(idx,itm) {
			$(el).children('div.vboxVMListGroupVMs').append(itm);
		});
		
		self.composeGroupDef();

	};
	
	/*
	 * Rename selected group
	 */
	self.renameSelectedGroup = function() {
		
		var el = $(self.getSelectedGroupElements()[0]);
		
		// Function to rename group
		var renameGroup = function(e, textbox) {
			
			if(!textbox) textbox = $(this);
			
			var newName = $(textbox).val().replace(/[\\\/:*?"<>,]/g,'_');
			
			if(newName && newName != $(textbox).closest('div.vboxVMListGroup').children('div.vboxVMListGroupHeader').attr('title')) {
				
				// Do not rename if it conflicts
				var noConflict = newName;
				var i = 2;
				while(self.groupNameConflicts($(textbox).parent().parent().parent().parent(), noConflict)) {
					noConflict = newName + ' (' + (i++) + ')';
				}
				newName = noConflict;
				
				$(textbox).closest('div.vboxVMListGroup')
					.children('div.vboxVMListGroupHeader').attr({'title':newName})
					.children('span.vboxVMListGroupName').html(newName);

				self.composeGroupDef();
			}
			
			
			$(textbox).parent().parent().children().show();
			$(textbox).parent().empty().remove();
		};
		
		$(el).children('div.vboxVMListGroupHeader').children().hide();
		$(el).children('div.vboxVMListGroupHeader').append(
			
			$('<form />').append(
				$('<input />').attr({'type':'text','value':$(el).children('div.vboxVMListGroupHeader').attr('title')}).css({'width':'90%','padding':'0px','margin':'0px'}).bind('keypress',function(e){
					if (e.which == 13) {
						$(this).unbind('blur', renameGroup);
						renameGroup(e,this);
						e.stopPropagation();
						e.preventDefault();
						$(this).trigger('blur');
						return false;
					}
				})
			)

		);
		$(el).children('div.vboxVMListGroupHeader').children('form').children('input').focus().select().blur(renameGroup);

	};

	/*
	 *
	 * Main run() function. Should only be called once. Though
	 * stop() and start() can be called many times.
	 *
	 */
	self.run = function() {
		
		if(self._running) return;

		// Subscribe to selected VM changes and refreshes
		$('#vboxIndex').bind('vmlistreload',function() {

			// Stop vmlist from refreshing..
			self.stop();
			
			// reset selections
			$('#vboxIndex').trigger('vmSelectionListChanged', [self]);

			// ask for new one
			vboxAjaxRequest('vboxGetMachines',{},function(d){
				self.start();
				self.updateList(d);
			});
			
			
		}).bind('vmlistrefresh',function(){
			self.refresh();
			
		}).bind('hostChange',function(){
			self.stop();
			$('#vboxIndex').trigger('vmSelectionListChanged', [self]);
			
		}).bind('hostChanged',function(){

			// These may change based on host configuration
			self.enforceVMOwnership = $('#vboxIndex').data('vboxConfig').enforceVMOwnership;

			self.start();
			
		}).bind('vmChanged',self.vmChanged);
		
		/*
		 *
		 * VM Group context menu items
		 *
		 */
		self.vmGroupContextMenuObj = new vboxMenu(self.anchorid+'vmgroups');
		self.vmGroupContextMenuObj.context = 'VBoxSelectorWnd';
		self.vmGroupContextMenuObj.addMenu(self.vmGroupContextMenuItems);
		
		// No need for these anymore
		delete selfvmGroupContextMenuItems;
		
		
		// Update context menus when selected VM changes
		$('#vboxIndex').bind('vmSelectionListChanged',function(){
			self.vmGroupContextMenuObj.update(self);
		});

		
		/*
		 *
		 * VM List context menu items?
		 *
		 */
		self.vmContextMenuObj = new vboxMenu(self.anchorid+'vms');
		self.vmContextMenuObj.context = 'VBoxSelectorWnd';
		self.vmContextMenuObj.addMenu(self.vmContextMenuItems);
		
		// Update context menu when selected VM changes
		$('#vboxIndex').bind('vmSelectionListChanged',function(){
			self.vmContextMenuObj.update(self);
		}).bind('vmChanged',function(){
			self.vmContextMenuObj.update(self);
		});
		
		// No need for these anymore
		delete self.vmContextMenuItems;
		
		/*
		 *
		 * Parent element context menu
		 *
		 */
		var vboxVMListPaneMenu = new vboxMenu(self.anchorid+'Pane');
		vboxVMListPaneMenu.addMenu(self.parentContextMenuItems);

		$('#'+self.anchorid).parent().contextMenu({
		  		menu: vboxVMListPaneMenu.menuId()
		  	},
		  	vboxVMListPaneMenu.menuClickCallback
		);
		
		// no need for these anymore
		delete self.parentContextMenuItems;
		
		
		// Add dragging target class on hover
		$(self.anchor).hover(function(){
			$(this).addClass('vboxVMListDropTargetHoverRoot');
		},function() {
			$(this).removeClass('vboxVMListDropTargetHoverRoot');
		});
		
		
		
		self.start();

	};
		
	/*
	 * Select a single item in our list
	 */
	self.selectItem = function(e) {
		
		var selectedList = [];
		var item = $(this);
		
		
		// Group?
		if($(item).hasClass('vboxVMListGroupHeader')) {
			
			
			// No control key. Exclusive selection
			if(!e.ctrlKey && !e.metaKey) {
				
				self.anchor.find('.vboxListItemSelected').removeClass('vboxListItemSelected');
				self.anchor.find('div.vboxGroupSelected').removeClass('vboxGroupSelected');
				
				// select current group
				$(item).parent().addClass('vboxGroupSelected');

				selectedList = [{
					type: 'group',
					groupPath: $(item).parent().data('vmGroupPath')
				}];

			// Already selected, and ctrl key
			} else if($(item).parent().hasClass('vboxGroupSelected')){
				
				// Deselect item
				selectedList = self.selectedList.filter(function(v){
					return (v.type != 'group' || (v.groupPath != $(item).parent().data('vmGroupPath')));
				});
			
			// Not already selected, and ctrl key
			} else {
	
				$(item).parent().addClass('vboxGroupSelected');
				
				selectedList = self.selectedList;
				
				selectedList[selectedList.length] = {
					type: 'group',
					groupPath: $(item).parent().data('vmGroupPath')
				};
				
			}
			
			
		// VM
		} else {
			
			// No ctrl key or selection is host. Exclusive selection
			if((!e.ctrlKey && !e.metaKey) || $(item).data('vmid') == 'host') {
				
				self.anchor.find('.vboxListItemSelected').removeClass('vboxListItemSelected');
				self.anchor.find('div.vboxGroupSelected').removeClass('vboxGroupSelected');
				
				// Select current VM
				$(item).addClass('vboxListItemSelected').removeClass('vboxHover');
				
				selectedList = [{
					type: 'vm',
					id: $(item).data('vmid'),
					groupPath: $(item).parent().data('vmGroupPath')
				}];
				
			// Already selected, and ctrl key
			} else if($(item).hasClass('vboxListItemSelected')) {

				// Deselect item
				selectedList = self.selectedList.filter(function(v){
					return (v.type == 'group' || (v.id != $(item).data('vmid')));
				});
			
			// ctrl key, but not already selected
			} else {
				
				$(item).addClass('vboxListItemSelected').removeClass('vboxHover');
				
				selectedList = self.selectedList;
				
				selectedList[selectedList.length] = {
					type: 'vm',
					id: $(item).data('vmid'),
					groupPath: $(item).parent().data('vmGroupPath')
				};
				
			}
			
		}

		// Remove host?
		if(selectedList.length > 1) {

			// Deselect host
			selectedList = selectedList.filter(function(v){
				return (v.type == 'group' || (v.id != 'host'));
			});
			
			self.anchor.children('table.vboxVMListItem-'+self.anchorid+'-host').removeClass('vboxListItemSelected');
			
		}
		self.selectedList = selectedList;
		self.selectionListChanged(self.selectedList);

		
	};
	
	/*
	 * Return HTML for group with VM place-holders
	 */
	self.groupHTML = function(gpath) {
		
	 	var first = (!gpath || gpath == '/');
	 	var gname = gpath.substring(gpath.lastIndexOf('/')+1);
		var gHTML = $('<div />').append(
			$('<div />').addClass('vboxVMListGroupHeader').css({'display':(first ? 'none' : '')})
				.attr({'title':gname})
				.dblclick(function() {
					$(this).children('span.vboxVMListGroupNameArrowCollapse').click();
				})
				.append(
						$('<div />').addClass('vboxVMListDropTarget')
							.addClass('vboxDropTargetTop').hover(function(){
							if(self._draggingGroup)
								$(this).addClass('vboxVMListDropTargetHover' + (first ? 'ignore' : ''));
						}, function(){
							$(this).removeClass('vboxVMListDropTargetHover');
						})
				)
				.append(
						$('<span />').addClass('vboxVMListGroupNameArrowCollapse')
							.click(function(e) {
								$(this).closest('div.vboxVMListGroup').toggleClass('vboxVMGroupCollapsed', 300);
								if(e) {
									e.stopPropagation();
									e.preventDefault();
								}

								return false;
							})
				)
				.append($('<span />').html(gname).addClass('vboxVMListGroupName'))
				.append($('<span />').addClass('vboxVMListGroupInfo').html(
						"<span class='vboxVMListGroupCounts' />" +
						//(gdef.subgroups.length ? ('<img src="images/vbox/nw_16px.png" />'+gdef.subgroups.length) : '') +
						//(gdef.machines.length ? (' <img src="images/vbox/fullscreen_16px.png" />'+gdef.machines.length) : '') +
						'' //'<img src="images/arrow_grad_up.png" />'
						))
				.append(
					$('<div />').addClass('vboxVMListDropTarget').addClass('vboxVMListDropTargetBottom')
						.hover(function(){
							if(self._draggingGroup)
								$(this).addClass('vboxVMListDropTargetHover');
						}, function(){
							$(this).removeClass('vboxVMListDropTargetHover');
					})

				)
				.hover(function(){
					$(this).addClass('vboxHover');
				},function(){
					$(this).removeClass('vboxHover');
				}).bind('click',self.selectItem)				

			).addClass((first ? 'vboxVMlistGroupRoot' : '')).addClass('vboxVMListGroup')
			.data({'vmGroupPath':gpath})
			.draggable({'cursorAt':{left: -10, top: -10},'helper':function(){
				
				return $(this).clone().addClass('vboxVMGroupCollapsed').addClass('vboxGroupSelected')
					.children('div.vboxVMListGroupHeader').removeClass('vboxHover').children('span.vboxVMListGroupNameArrowCollapse').hide()
					.parent().parent().css({'width':$(this).width()+'px'});
									
				
				},'start':function() {
										
					self.paused = true;
					self._draggingGroup = $(this).data('vmGroupPath');
					$(self.anchor).disableSelection();
				
				},'stop':function(e) {
					self.vmGroupDropped(e,$(this));					
					self.paused = false;
					
			}}).append($('<div />').addClass('vboxVMListGroupVMs'));


		/*		
		// Append sub-groups
		for(var i = 0; i < gdef.subgroups.length; i++) {
			gHTML.append(self.groupHTML(gdef.subgroups[i]));
		}
		
		// Append VM placeholders
		var vmlist = $('<div />').addClass('vboxVMListGroupVMs');
		if(gdef.machines.length) {
			for(var i = 0; i < gdef.machines.length; i++) {
				vmlist.append(
					$('<table />').addClass('vboxVMListItem-'+self.anchorid+'-'+gdef.machines[i])
				);
			}
		}
		
		gHTML.append(vmlist);
		*/
		
		// Bottom drop target
		if(!first) {
			gHTML.append(
				$('<div />').addClass('vboxVMListDropTarget').addClass('vboxVMListDropTargetBottom')
					.hover(function(){
						if(self._draggingGroup)
							$(this).addClass('vboxVMListDropTargetHover');
					}, function(){
						$(this).removeClass('vboxVMListDropTargetHover');
				})
			);
		}

		

		// Group context menu
		$(gHTML).contextMenu({
			menu: self.vmGroupContextMenuObj.menuId(),
			menusetup: function(el) {
				$(el).children('div.vboxVMListGroupHeader').trigger('click');
			}
		},function(act,el,pos,d,e){
			self.vmGroupContextMenuObj.menuClickCallback(act, el);
		});
		
		return gHTML;
		
		
	
	};
	
	/*
	 * Return vm data
	 */
	self.getVMData = function(vmid) {
		return self.vms[vmid];
	};
	
	/*
	 * Return selected VM elements
	 */
	self.getSelectedVMElements = function() {
		return self.anchor.find('table.vboxSelected');
	};
	
	/*
	 * Return selected group elements
	 */
	self.getSelectedGroupElements = function() {
		return self.anchor.find('div.vboxGroupSelected');
	};
	
	
	/*
	 * Start VM list update
	 */ 
	self.start = function(noinit) {
		
		// already started
		if(self._running) return;
		
		var cb = function() {
			vboxAjaxRequest('vboxGetMachines',{},function(d) {
				self.updateList(d);
			});			
		};
		
		// noinit is passed by refresh() since it just
		// updated the list we don't need to immediately
		// refresh it again
		if(!noinit) cb();
		
		
		self._running = window.setInterval(cb,self.interval*1000);
		
		
	};
	
	/*
	 * Stop VM list updates and clear list
	 */
	self.stop = function() {
		if(!self._running) return;
		window.clearInterval(self._running);
		self._running = null;
		self.anchor.html("<div id='vboxVMListSpinner' style='text-align: center'><img src='images/spinner.gif' /></div>");
		
		// reset vars
		self.vms = null;
		self.versionChecked = false;
		self.selectedList = [];
		self.selectedVMs = [];
		self.selectionModel = null;
	};
	
	
	/* Force an imediate background refresh. Called when a VM
	 * attribute change is expected and we want it to show up
	 * asap.
	 */
	self.refresh = function() {
		
		// Stop refresh interval
		if(self._running)
			window.clearInterval(self._running);
		
		// If we happen to get data in the background,
		// ignore it because the update we're about to
		// perform will be more authoritative. See updateList()
		self._running = null;
		
		vboxAjaxRequest('vboxGetMachines',{},function(d) {
			self.start(true);
			self.updateList(d);
		});			
		
	};

}

</script>
